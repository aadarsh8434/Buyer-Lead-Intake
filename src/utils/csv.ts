// utils/csv.ts
import { Buyer } from "@/types/buyer";
import { formatDate } from "./formatting";
import { CsvRowData, csvRowSchema } from "./validation";

export interface CsvImportResult {
  validRows: Buyer[];
  errors: Array<{
    row: number;
    errors: string[];
    data: any;
  }>;
}

export const exportBuyersToCSV = (buyers: Buyer[], filename?: string): void => {
  const headers = [
    "Full Name",
    "Email",
    "Phone",
    "City",
    "Property Type",
    "BHK",
    "Purpose",
    "Budget Min",
    "Budget Max",
    "Timeline",
    "Source",
    "Status",
    "Notes",
    "Tags",
    "Updated At",
  ];

  const csvData = buyers.map((buyer) => [
    buyer.fullName,
    buyer.email || "",
    buyer.phone,
    buyer.city,
    buyer.propertyType,
    buyer.bhk || "",
    buyer.purpose,
    buyer.budgetMin || "",
    buyer.budgetMax || "",
    buyer.timeline,
    buyer.source,
    buyer.status,
    buyer.notes || "",
    buyer.tags ? buyer.tags.join(";") : "",
    formatDate(buyer.updatedAt),
  ]);

  const csvContent = [headers, ...csvData]
    .map((row) =>
      row.map((field) => `"${String(field).replace(/"/g, '""')}"`).join(",")
    )
    .join("\n");

  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download =
    filename || `buyers-${new Date().toISOString().split("T")[0]}.csv`;
  link.click();
  URL.revokeObjectURL(url);
};

export const parseCsvFile = (file: File): Promise<CsvRowData[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const csv = e.target?.result as string;
        const rows = csv.split("\n").filter((row) => row.trim());

        if (rows.length < 2) {
          reject(
            new Error("CSV file must have at least a header and one data row")
          );
          return;
        }

        const headers = rows[0]
          .split(",")
          .map((h) => h.replace(/"/g, "").trim().toLowerCase());
        const expectedHeaders = [
          "fullname",
          "email",
          "phone",
          "city",
          "propertytype",
          "bhk",
          "purpose",
          "budgetmin",
          "budgetmax",
          "timeline",
          "source",
          "notes",
          "tags",
          "status",
        ];

        // Validate headers
        const missingHeaders = expectedHeaders.filter(
          (h) => !headers.includes(h)
        );
        if (missingHeaders.length > 0) {
          reject(
            new Error(`Missing required headers: ${missingHeaders.join(", ")}`)
          );
          return;
        }

        const data: CsvRowData[] = [];
        for (let i = 1; i < rows.length; i++) {
          const values = rows[i]
            .split(",")
            .map((v) => v.replace(/"/g, "").trim());
          const rowData: any = {};

          headers.forEach((header, index) => {
            const value = values[index] || "";
            switch (header) {
              case "fullname":
                rowData.fullName = value;
                break;
              case "propertytype":
                rowData.propertyType = value;
                break;
              case "budgetmin":
                rowData.budgetMin = value;
                break;
              case "budgetmax":
                rowData.budgetMax = value;
                break;
              default:
                rowData[header] = value;
            }
          });

          data.push(rowData);
        }

        resolve(data);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = () => reject(new Error("Failed to read file"));
    reader.readAsText(file);
  });
};

export const validateCsvRows = (data: CsvRowData[]): CsvImportResult => {
  const validRows: Buyer[] = [];
  const errors: CsvImportResult["errors"] = [];

  data.forEach((row, index) => {
    try {
      // Convert string numbers to actual numbers
      const processedRow = {
        ...row,
        budgetMin:
          row.budgetMin && row.budgetMin !== ""
            ? parseInt(row.budgetMin)
            : undefined,
        budgetMax:
          row.budgetMax && row.budgetMax !== ""
            ? parseInt(row.budgetMax)
            : undefined,
        tags: row.tags
          ? row.tags
              .split(";")
              .map((t) => t.trim())
              .filter((t) => t)
          : undefined,
      };

      const validatedRow = csvRowSchema.parse(processedRow);

      // Convert to Buyer format
      const buyer: Buyer = {
        id: "", // Will be generated by backend
        fullName: validatedRow.fullName,
        email: validatedRow.email || undefined,
        phone: validatedRow.phone,
        city: validatedRow.city,
        propertyType: validatedRow.propertyType,
        bhk: validatedRow.bhk || undefined,
        purpose: validatedRow.purpose,
        budgetMin: processedRow.budgetMin,
        budgetMax: processedRow.budgetMax,
        timeline: validatedRow.timeline,
        source: validatedRow.source,
        status: validatedRow.status || "New",
        notes: validatedRow.notes || undefined,
        tags: processedRow.tags,
        ownerId: "", // Will be set by backend
        updatedAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      };

      validRows.push(buyer);
    } catch (error: any) {
      const errorMessages: string[] = [];

      if (error.errors) {
        error.errors.forEach((err: any) => {
          errorMessages.push(`${err.path.join(".")}: ${err.message}`);
        });
      } else {
        errorMessages.push(error.message || "Invalid row data");
      }

      errors.push({
        row: index + 2, // +2 because array is 0-indexed and we skip header
        errors: errorMessages,
        data: row,
      });
    }
  });

  return { validRows, errors };
};

export const downloadCsvTemplate = (): void => {
  const headers = [
    "fullName",
    "email",
    "phone",
    "city",
    "propertyType",
    "bhk",
    "purpose",
    "budgetMin",
    "budgetMax",
    "timeline",
    "source",
    "notes",
    "tags",
    "status",
  ];

  const sampleRow = [
    "John Doe",
    "john@example.com",
    "9876543210",
    "Chandigarh",
    "Apartment",
    "3",
    "Buy",
    "5000000",
    "7000000",
    "0-3m",
    "Website",
    "Sample notes",
    "urgent;first-time-buyer",
    "New",
  ];

  const csvContent = [headers, sampleRow]
    .map((row) => row.map((field) => `"${field}"`).join(","))
    .join("\n");

  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "buyer-import-template.csv";
  link.click();
  URL.revokeObjectURL(url);
};
